BankPlus is a moderately complex example application that demonstrates the design and development of a payment banking application.

The accompanying tutorial is targetted towards an audience having basic working knowledge about :

* AngularJS
* Java EE 7

Some knowledge of JBoss Enterprise Application Platform is useful, but you may still find the tutorial useful if you are approaching the development of this application from the perspective of another Java EE application server.

Chapter 1 describes the use cases and the business and technical architecture of the system. The tutorial sets about introducing the use cases for a hypothetical payment bank and the proceeds to outline the business architecture for such a banking system. Once the business architecture is established, the accompanying technical architecture would be created. While these terms may sound scary for a beginner, we'll attempt to simplify them and present their utility in architecting, designing and developing the application.

Chapter 2 sets out to design the front-end of the system in accordance with the use cases described in the previous chapter. We'll use a combination of BootStrap 3 and AngularJS to develop the frontend. We'll also use Yeoman, Bower and Grunt to aid in developing the front-end. Yeoman would be utilized to quickly scaffold up the front-end. Bower would be used for dependency management, and Grunt would be used in automating the build and deploy cycle for the JavaScript heavy front-end.

In Chapter 3, we'll explore how to design and create a REST API to integrate with the front-end. We'll be using JAX-RS for developing the REST API. The business logic would be encapsulated in Stateless Session EJBs that are developed around a domain model for accounting systems. These EJBs would be injected into the JAX-RS resource classes so as to expose the domain model to the application layer. Not all business logic would be exposed to the front-end; this is a banking system after all, and we'll take the opportunity to use message driven beans (MDBs) to process events that are generated outside the bank, in a transactional manner. We'll use a scheduled job to assume the role of generating events as if they were generated by the banking network in which the bank operates.

In Chapter 4, an introduction to microservices would be presented in the context of the payment bank. The business architecture would be revisited in order to understand how multiple teams would implement the various services of the bank. We'll study the existing monolithic technical architecture of the system and how such an architecture may introduce inefficiencies in shipping and deploying new features. Microservices as an architectural style would be introduced as a solution because it allows various modules in the original architecture to be designed and developed as independently deployable units. We'll study how multiple teams could operate in relative independence at different velocities if their development and deployment cycles would be broken out from a single line of development into multiple lines. Each microservice can be developed on by a team independently of other microservices, and for the most part, changes to a single microservice can be deployed without requiring other teams to deploy changes to their microservices.

In Chapter 5, we decompose the existing monolithic application into several microservices. We'll utilize the concept of an Anti-Corruption Layer to individually extract every microservice without compromising on the correctness and functionality of the application during the decomposition phase.

In Chapter 6, we'll then move onto deploying and operating the microservices style application on a platform suitable for such services, namely OpenShift, through the use of underlying technologies - Docker and Kubernetes. We'll also extend the functionality of a select few microservices to demonstrate how the microservices architecture brings greater agility to the bank, by allowing business requests to be developed and implemented by one or more technical implementation teams and for such changes to deployed to production without waiting for deliverables from other teams.
