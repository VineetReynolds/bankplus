BankPlus is a moderately complex example application that demonstrates the design and development of a payment banking application.

The accompanying tutorial is targetted towards an audience having basic working knowledge about :

* Java EE 7
* AngularJS

Some knowledge of JBoss Enterprise Application Platform is useful, but you may still find the tutorial useful if you are approaching the development of this application from the perspective of another Java EE application server.

Chapter 1 describes the use cases and the business and technical architecture of the system. The tutorial sets about introducing the use cases for a hypothetical payment bank and the proceeds to outline the business architecture for such a banking system. Once the business architecture is established, the accompanying technical architecture would be created. While these terms may sound scary for a beginner, we'll attempt to simplify them and present their utility in architecting, designing and developing the application.

Chapter 2 sets out to design the front-end of the system in accordance with the use cases described in the previous chapter. We'll use a combination of BootStrap 3 and AngularJS to develop the frontend. We'll also use Yeoman, Bower and Grunt to aid in developing the front-end. Yeoman would be utilized to quickly scaffold up the front-end. Bower would be used for dependency management, and Grunt would be used in automating the build and deploy cycle for the JavaScript heavy front-end.

In Chapter 3, we'll explore how to design and create a REST API to integrate with the front-end. We'll be using JAX-RS for developing the REST API. The business logic would be encapsulated in Stateless Session EJBs that are developed around a domain model for accounting systems. These EJBs would be injected into the JAX-RS resource classes so as to expose the domain model to the application layer. Not all business logic would be exposed to the front-end; this is a banking system after all, and we'll take the opportunity to use message driven beans (MDBs) to process events that are generated outside the bank, in a transactional manner. We'll use a scheduled job to assume the role of generating events as if they were generated by the banking network in which the bank operates.

In Chapter 4, an introduction to microservices would be presented in the context of the payment bank. The business architecture would be revisited in order to understand how multiple teams would implement the various services of the bank. We'll study the existing monolithic technical architecture of the system and how such an architecture may introduce inefficiencies in shipping and deploying new features. Microservices as an architectural style would be introduced as a solution because it allows various modules in the original architecture to be designed and developed as independently deployable units. We'll study how multiple teams could operate in relative independence at different velocities if their development and deployment cycles would be broken out from a single line of development into multiple lines. Each microservice can be developed on by a team independently of other microservices, and for the most part, changes to a single microservice can be deployed without requiring other teams to deploy changes to their microservices.

In Chapter 5, we decompose the existing monolithic application into several microservices. We'll utilize the concept of an Anti-Corruption Layer to individually extract every microservice without compromising on the correctness and functionality of the application during the decomposition phase.

We'll then move onto deploying and operating the microservices style application on a platform suitable for such services, namely OpenShift, through the use of underlying technologies - Docker and Kubernetes.

Microservices is a fairly recent architectural style that revolves around designing applications in the form of independent deployable units focussing on specific bounded contexts. They are a response to the monolithic style of developing and deploying applications.

In a sense, they can be termed as "hipster SOA", as the focus is on developing applications using a service-oriented architecture. Unlike contemporary SOA applications, a lot more intelligence resides in the nodes where the microservices run, instead of in the interconnecting infrastructure.

The monolithic style of deploying applications treats an application as a single deployable unit. The deployable unit is often a single WAR, with the necessary libraries provided by the application server.

This is an example application that uses a micro-services architecture to implement payment (or fund transfers, depending on how you look at it)  services offered by a bank. Inspired by Simple among others.
For now, the scope of the services is limited, to keep the overhead of understanding the application and architecture.
Hence, we limit ourselves to building services to handle
customer account registration, 
provide a general ledger and journal for accounting
and transfer of money between accounts (read as payments, or fund transfers).

However, since we must not forget that a microservices architecture is adopted for the sake of agility, we may have to add additional services (like a lending service, or a limits service) in the future that operate with the existing services. The bank therefore, operates as a “payment bank”. Such banks are licensed to only serve the purpose of payments and remittances; they are not allowed to engage in lending and thus offer no loans. A broader license is required for engaging in lending activities.

An attempt will be made to solve payments across accounts in different banks using the concept of Nostro/Vostro accounts, but we won't integrate with SWIFT, TARGET, ACH or any other payment or electronic money transfer system in the real-world. We will manage only one Nostro/Vostro combination - this would be an account managed by a hypothetical clearing house or clearing exchange. BankPlus would maintain two accounts - it’s nostro account representing it’s  real account at a clearing house/exchange (like ACH), and a vostro account representing the account for the exchange at BankPlus. Transfers are routed to other banks through the clearing house/exchange. We will not implement a clearing exchange, and thus only maintain a single account in BankPlus (the vostro) that tracks the position/balance of the bank at the exchange. However, we may show how (in an appendix or a separate document/guide) the possibility of integration with a real-world exchange through extending the application with another service.

Additionally, other services for mobile (aka smartphone) users may be built, like uploading of cheques via smartphones directly to the account (inspired by the photo-deposit feature of Simple). This would of course be dependent on time constraints, and whether there is any value added to end-users (software developers, and not hypothetical users of a banking service). 

Most of the use cases are based on existing services provided by banks and payment services. But we will not attempt to mimic banks in their entirety. Software architectures in banks may not provide certain features due to various non-technical reasons. For instance, customer account data is not available in a portable manner to the customers of banks. Therefore, we currently have services like Mint and Yodlee that do not attempt to get raw data from the bank accounts, but instead screen scrape for information. These services use your bank account credentials to login and extract this data from the bank sites. This situation is expected to remain unchanged until there is a mass shift in perception. BankPlus, however, will demonstrate data portability through APIs; and thus we will use OAuth to secure services. This is also being done, so that the application and it's architecture will be useful to software developers catering other industries, and not just banking.